From ed1c01e8d36dff7b83a484c5f24f86311c14ecd6 Mon Sep 17 00:00:00 2001
From: Christian Stewart <christian@paral.in>
Date: Fri, 15 Feb 2019 18:19:41 -0800
Subject: [PATCH 2/2] arch: add support for arm

Adds support for the "arm" target architecture.

This is experimental.

Signed-off-by: Christian Stewart <christian@paral.in>
---
 arch/arm-options.mk          |  12 +++
 cli/kata-check_arm.go        | 132 +++++++++++++++++++++++++++++
 cli/utils_arch_base.go       |   2 +-
 cli/utils_arm.go             |   7 ++
 virtcontainers/hypervisor.go |   2 +-
 virtcontainers/qemu_arm.go   | 155 +++++++++++++++++++++++++++++++++++
 6 files changed, 308 insertions(+), 2 deletions(-)
 create mode 100644 arch/arm-options.mk
 create mode 100644 cli/kata-check_arm.go
 create mode 100644 cli/utils_arm.go
 create mode 100644 virtcontainers/qemu_arm.go

diff --git a/arch/arm-options.mk b/arch/arm-options.mk
new file mode 100644
index 0000000..66e6138
--- /dev/null
+++ b/arch/arm-options.mk
@@ -0,0 +1,12 @@
+# Copyright (c) 2018 Intel Corporation
+#
+# SPDX-License-Identifier: Apache-2.0
+#
+
+# ARM 64 settings
+
+MACHINETYPE := virt
+KERNELPARAMS :=
+MACHINEACCELERATORS :=
+
+QEMUCMD := qemu-system-arm
diff --git a/cli/kata-check_arm.go b/cli/kata-check_arm.go
new file mode 100644
index 0000000..0b116ad
--- /dev/null
+++ b/cli/kata-check_arm.go
@@ -0,0 +1,132 @@
+// Copyright (c) 2018 Intel Corporation
+//
+// SPDX-License-Identifier: Apache-2.0
+//
+
+package main
+
+import (
+	"fmt"
+
+	"github.com/sirupsen/logrus"
+)
+
+const (
+	cpuFlagsTag        = "Features"
+	archCPUVendorField = "CPU implementer"
+	archCPUModelField  = "CPU architecture"
+)
+
+// archRequiredCPUFlags maps a CPU flag value to search for and a
+// human-readable description of that value.
+var archRequiredCPUFlags = map[string]string{}
+
+// archRequiredCPUAttribs maps a CPU (non-CPU flag) attribute value to search for
+// and a human-readable description of that value.
+var archRequiredCPUAttribs = map[string]string{}
+
+// archRequiredKernelModules maps a required module name to a human-readable
+// description of the modules functionality and an optional list of
+// required module parameters.
+var archRequiredKernelModules = map[string]kernelModule{
+	"kvm": {
+		desc: "Kernel-based Virtual Machine",
+	},
+	"vhost": {
+		desc: "Host kernel accelerator for virtio",
+	},
+	"vhost_net": {
+		desc: "Host kernel accelerator for virtio network",
+	},
+}
+
+func setCPUtype() error {
+	return nil
+}
+
+// kvmIsUsable determines if it will be possible to create a full virtual machine
+// by creating a minimal VM and then deleting it.
+func kvmIsUsable() error {
+	return genericKvmIsUsable()
+}
+
+func archHostCanCreateVMContainer() error {
+	return kvmIsUsable()
+}
+
+// hostIsVMContainerCapable checks to see if the host is theoretically capable
+// of creating a VM container.
+func hostIsVMContainerCapable(details vmContainerCapableDetails) error {
+
+	_, err := getCPUInfo(details.cpuInfoFile)
+	if err != nil {
+		return err
+	}
+
+	count, err := checkKernelModules(details.requiredKernelModules, archKernelParamHandler)
+	if err != nil {
+		return err
+	}
+
+	if count == 0 {
+		return nil
+	}
+
+	return fmt.Errorf("ERROR: %s", failMessage)
+
+}
+
+func archKernelParamHandler(onVMM bool, fields logrus.Fields, msg string) bool {
+	return genericArchKernelParamHandler(onVMM, fields, msg)
+}
+
+// The CPU Vendor here for Arm means the CPU core
+// IP Implementer.
+// normalizeArmVendor maps 'CPU implementer' in /proc/cpuinfo
+// to human-readable description of that value.
+func normalizeArmVendor(vendor string) string {
+
+	switch vendor {
+	case "0x41":
+		vendor = "ARM Limited"
+	default:
+		vendor = "3rd Party Limited"
+	}
+
+	return vendor
+}
+
+// The CPU Model here for Arm means the Instruction set, that is
+// the variant number of Arm processor.
+// normalizeArmModel maps 'CPU architecture' in /proc/cpuinfo
+// to human-readable description of that value.
+func normalizeArmModel(model string) string {
+	switch model {
+	case "8":
+		model = "v8"
+	case "7", "7M", "?(12)", "?(13)", "?(14)", "?(15)", "?(16)", "?(17)":
+		model = "v7"
+	case "6", "6TEJ":
+		model = "v6"
+	case "5", "5T", "5TE", "5TEJ":
+		model = "v5"
+	case "4", "4T":
+		model = "v4"
+	case "3":
+		model = "v3"
+	default:
+		model = "unknown"
+	}
+
+	return model
+}
+
+func getCPUDetails() (string, string, error) {
+	vendor, model, err := genericGetCPUDetails()
+	if err == nil {
+		vendor = normalizeArmVendor(vendor)
+		model = normalizeArmModel(model)
+	}
+
+	return vendor, model, err
+}
diff --git a/cli/utils_arch_base.go b/cli/utils_arch_base.go
index a0c6a5e..67f0e30 100644
--- a/cli/utils_arch_base.go
+++ b/cli/utils_arch_base.go
@@ -1,4 +1,4 @@
-// +build !s390x
+// +build !s390x,!arm
 //
 // SPDX-License-Identifier: Apache-2.0
 //
diff --git a/cli/utils_arm.go b/cli/utils_arm.go
new file mode 100644
index 0000000..e2d7f43
--- /dev/null
+++ b/cli/utils_arm.go
@@ -0,0 +1,7 @@
+// SPDX-License-Identifier: Apache-2.0
+
+package main
+
+func archConvertStatFs(cgroupFsType int) int32 {
+	return int32(cgroupFsType)
+}
diff --git a/virtcontainers/hypervisor.go b/virtcontainers/hypervisor.go
index dd37f87..c987a22 100644
--- a/virtcontainers/hypervisor.go
+++ b/virtcontainers/hypervisor.go
@@ -544,7 +544,7 @@ func getHostMemorySizeKb(memInfoPath string) (uint64, error) {
 
 // RunningOnVMM checks if the system is running inside a VM.
 func RunningOnVMM(cpuInfoPath string) (bool, error) {
-	if runtime.GOARCH == "arm64" || runtime.GOARCH == "ppc64le" || runtime.GOARCH == "s390x" {
+	if runtime.GOARCH == "arm" || runtime.GOARCH == "arm64" || runtime.GOARCH == "ppc64le" || runtime.GOARCH == "s390x" {
 		virtLog.Info("Unable to know if the system is running inside a VM")
 		return false, nil
 	}
diff --git a/virtcontainers/qemu_arm.go b/virtcontainers/qemu_arm.go
new file mode 100644
index 0000000..6a3cef7
--- /dev/null
+++ b/virtcontainers/qemu_arm.go
@@ -0,0 +1,155 @@
+// Copyright (c) 2018 Intel Corporation
+//
+// SPDX-License-Identifier: Apache-2.0
+//
+
+package virtcontainers
+
+import (
+	"io/ioutil"
+	"runtime"
+	"strings"
+
+	govmmQemu "github.com/intel/govmm/qemu"
+	"github.com/sirupsen/logrus"
+)
+
+type qemuArm32 struct {
+	// inherit from qemuArchBase, overwrite methods if needed
+	qemuArchBase
+}
+
+const defaultQemuPath = "/usr/bin/qemu-system-arm"
+
+const defaultQemuMachineType = QemuVirt
+
+var defaultQemuMachineOptions = "usb=off,accel=kvm,gic-version=" + getGuestGICVersion()
+
+// Not used
+const defaultPCBridgeBus = ""
+
+var qemuPaths = map[string]string{
+	QemuVirt: defaultQemuPath,
+}
+
+var kernelParams = []Param{
+	{"console", "hvc0"},
+	{"console", "hvc1"},
+	{"iommu.passthrough", "0"},
+}
+
+var kernelRootParams = []Param{
+	{"root", "/dev/vda1"},
+}
+
+var supportedQemuMachines = []govmmQemu.Machine{
+	{
+		Type:    QemuVirt,
+		Options: defaultQemuMachineOptions,
+	},
+}
+
+// Logger returns a logrus logger appropriate for logging qemu-aarch64 messages
+func qemuArmLogger() *logrus.Entry {
+	return virtLog.WithField("subsystem", "qemu-aarch64")
+}
+
+// On ARM platform, we have different GIC interrupt controllers. Different
+// GIC supports different QEMU parameters for virtual GIC and max VCPUs
+var hostGICVersion = getHostGICVersion()
+
+// We will access this file on host to detect host GIC version
+var gicProfile = "/proc/interrupts"
+
+// Detect the host GIC version.
+// Success: return the number of GIC version
+// Failed: return 0
+func getHostGICVersion() (version uint32) {
+	bytes, err := ioutil.ReadFile(gicProfile)
+	if err != nil {
+		qemuArmLogger().WithField("GIC profile", gicProfile).WithError(err).Error("Failed to parse GIC profile")
+		return 0
+	}
+
+	s := string(bytes)
+	if strings.Contains(s, "GICv2") {
+		return 2
+	}
+
+	if strings.Contains(s, "GICv3") {
+		return 3
+	}
+
+	if strings.Contains(s, "GICv4") {
+		return 4
+	}
+
+	return 0
+}
+
+// QEMU supports GICv2, GICv3 and host parameters for gic-version. The host
+// parameter will let QEMU detect GIC version by itself. This parameter
+// will work properly when host GIC version is GICv2 or GICv3. But the
+// detection will failed when host GIC is gicv4 or higher. In this case,
+// we have to detect the host GIC version manually and force QEMU to use
+// GICv3 when host GIC is GICv4 or higher.
+func getGuestGICVersion() (version string) {
+	if hostGICVersion == 2 {
+		return "2"
+	}
+
+	if hostGICVersion >= 3 {
+		return "3"
+	}
+
+	// We can't parse valid host GIC version from GIC profile.
+	// But we can use "host" to ask QEMU to detect valid GIC
+	// through KVM API for a try.
+	return "host"
+}
+
+//In qemu, maximum number of vCPUs depends on the GIC version, or on how
+//many redistributors we can fit into the memory map.
+//related codes are under github.com/qemu/qemu/hw/arm/virt.c(Line 135 and 1306 in stable-2.11)
+//for now, qemu only supports v2 and v3, we treat v4 as v3 based on
+//backward compatibility.
+var gicList = map[uint32]uint32{
+	uint32(2): uint32(8),
+	uint32(3): uint32(123),
+	uint32(4): uint32(123),
+}
+
+// MaxQemuVCPUs returns the maximum number of vCPUs supported
+func MaxQemuVCPUs() uint32 {
+	if hostGICVersion != 0 {
+		return gicList[hostGICVersion]
+	}
+	return uint32(runtime.NumCPU())
+}
+
+func newQemuArch(config HypervisorConfig) qemuArch {
+	machineType := config.HypervisorMachineType
+	if machineType == "" {
+		machineType = defaultQemuMachineType
+	}
+
+	q := &qemuArm32{
+		qemuArchBase{
+			machineType:           machineType,
+			memoryOffset:          config.MemOffset,
+			qemuPaths:             qemuPaths,
+			supportedQemuMachines: supportedQemuMachines,
+			kernelParamsNonDebug:  kernelParamsNonDebug,
+			kernelParamsDebug:     kernelParamsDebug,
+			kernelParams:          kernelParams,
+		},
+	}
+
+	if config.ImagePath != "" {
+		q.kernelParams = append(q.kernelParams, kernelRootParams...)
+		q.kernelParamsNonDebug = append(q.kernelParamsNonDebug, kernelParamsSystemdNonDebug...)
+		q.kernelParamsDebug = append(q.kernelParamsDebug, kernelParamsSystemdDebug...)
+	}
+
+	return q
+}
-- 
2.19.2

